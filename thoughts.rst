Пямятка-детектор менеджеру проекта или как запустить сервис в срок
==================================================================

В статье будет рассмотрен список паразитной активности бекендеров на
*начальном* этапе разработки, которая не решает никаких проблем, и более того,
сама является источником оных. Если вы как ПМ уловите в разговорах подобные
топики это должно стать звоночком и побуждением к действию, только вы можете
спасти проект!

Внимание! Этот текст не для разработчиков, а для менеджеров и как им не надо
доверять технической команде в принятии технических же решений. Поэтому, если
при прочтении у вас возникает неумолимое желание поставить минус, значит вы
разработчик и это нормально.

В чем корень проблемы? К сожалению, правило 95% работает на любых множествах,
поэтому вероятность того что у вас "плохой" руководитель бека - 95%. Плохой
в данном контексте означает неэффективный, лид, который может пожертвовать
решением насущных проблем ради резюме, искреннего перфекционизма или простого
любопытства. Не важна причина, но так или иначе на проекте появляется ветряная
мельница с которой он будет доблестно сражаться.

ПМ должен уметь распознавать паразитную активность в зародыше и принять меры,
иначе ком вторичных проблем приведет к задержкам в плане и, в конечном итоге,
срыву сроков.

Немножко про меня: 15 лет опыта, проекты разной тематики, 3 года был лидом на
двух сервисах. Менеджером нет, не был и не хочу, поэтому, я - предатель, сдаю
коллег по цеху.

Хочется рассказать о своих и чужих ошибках, которые наблюдал в реальности,
ошибках дорогих, про которые обычно говорят "так сложилось исторически, ты не
представляешь что здесь было год назад". Ошибки, которых просто могло бы и не
быть, так как это всего лишь следствие борьбы с несуществующими проблемами.


Базовый чеклист
---------------

* Какую проблему мы решаем?

* Действительно ли это проблема?

* Можно ли решить проблему потом, какие будут последствия, если не решить проблему прямо сейчас?

* Можно ли решить проблему через реорганизацию процесса? (Удивительно, насколько
  много времени можно потратить на устранение человеческого фактора через
  автоматизацию, вместо того чтобы просто договориться. Да, ошибки будут, но
  они, как правило, не фатальны).

* Действительно ли представленное решение устраняет проблему?

* Сколько ресурсов нужно для решения?

* Можно ли устранить проблему частично, закрыв только критические последствия
  и сколько ресурсов потребуется тогда? Поиск компромисса.

Или, другими словами, всегда спрашивайте себя: "Не ***** ли я делаю?" Всего
лишь немного критического подхода.

Разработчикам желательно придерживаться чеклиста, но это сложно, я знаю, хе-хе.

Менеджерам необходимо придерживаться обязательно, им легче, так как не нужно быть
откровенными с самими собой. Не обязательно гонять бекендеров на митингах, за
обедом отличный вариант, если начинает мяться или рассказывать про Нью-Васюки
— чеклист не пройден. Старайтесь держать разговор в русле решаемой проблемы,
бекендеры скользки до невозможности, любят не ворочать мешки и легко уходят
в сторону.

Чеклист позволяет общаться на технические темы, даже не зная матчасти, уже на
"какую проблему мы решаем", начинаются проблемы в объяснении. Но не
воспринимайте это как отговорку, хороший менеджер обязан разбираться в деталях.

Так же я намеренно не затрагиваю soft skills, здесь каждый выбирает сам как
выстроить общение и когда дать разрядку, чтобы команда позанималась тратой
времени. Разработчик нынче пошел нежный, может убежать если его заставлять
работать, а других "инженеров" у ПМ нема.

С теорией покончено, перейдем к реальной боли. Еще раз напомню, все это
относится только к молодым проектам.


Код в нескольких репах
----------------------

Почему так делают для меня загадка. Разделение не через анализ
связанности/сцепленности (хотя какой анализ, кода то еще нет), а по внешним
признакам, например по способу деплоя, разворачивается же отдельно — значит это
разные репозитории, очевидно же. Или по организационным, например эта команда
будет делать бек, а эта админку, следовательно им нужные разные репы.

Классическое разделение: бекенд/админка. Но
это не предел, видел и бекенд/админка/модели, а также сакраментальный
core/бекенд/админка. Ох уж этот core, святой грааль и носитель общего кода.

Какую проблему решает? Никакую. Признаки того что для вашего проекта так
делать точно не стоило:

* Реализация фичи затрагивает сразу несколько реп. Фича порождает несколько пулреквестов,
  в разных VCS-проектах. Причина изменения кода одна, а правится он в нескольких местах.

* Проект может работать только с определенным набором версий, как правило, это
  последний master/develop, нет обратной совместимости, если обновили core, то
  нужно обновлять все остальное.

Кроме чисто организационных проблем, дополнительно нужно будет решать технические.

* Синхронизация кодовой базы на машине разработчика. Это или просто отдельные
  рабочие копии, или git submodules, c пресловутыми uncommitted changes
  в корне, или аналоги в mercurial. В условиях когда нужно просто фигачить код,
  ваша команда будет тратить время на выяснение какие конкретно версии нужны
  чтобы все завелось и работало. И это еще хорошо, когда просто не работает,
  есть трейс и понятно что делать. А может тихо портить данные и
  будет потрачено время, чтобы в итоге узнать, что причина в несвежем коде.

* Усложнение разворачивания на машинах разработчиков. Как ПМ, поинтересуйтесь,
  сколько времени занимает настройка проекта у нового сотрудника, может ли он
  развернуть сервис по README или для этого нужен специально обученный человек.
  Монолитные проекты тоже этим грешат, но вероятность нарваться на потерянные
  день/два в случае нескольких репозиториев гораздо выше. Самое забавное, что
  лид может быть свято уверен, что с первой настройкой проекта нет никаких
  проблем, у него недавно все работало. Но он знает, он это делал, и ключевые
  вещи для него являются мелкими деталями. Все это только в его голове.

* Не обязательно, но часто идет бонусной проблемой. Опакечивание кода согласно
  репозиториям. Преподносится как решение проблемы с доставкой зависимостей. Но
  так как обратной совместимости нет и волшебная комбинация рабочих версий
  никуда не делась, то на самом деле это очень шаткий костыль для следующего
  пункта.

* Как следствие, усложнение CI/CD. И это нельзя будет сбросить на админов,
  нужен или хороший devops, полностью вовлеченный в разработку, или
  отнимать время у лида, которого и так на всех не хватает. В полный рост
  проблема встает на простых CI, которые заточены только на монокод:
  gitlab-ci/circle/travis (пожалуй все облачные CI), приходится
  много прыгать, стучать в бубен и обмазываться скриптами.

* Бонусная проблема для бонусной проблемы. Артефакты для опакеченных зависимостей нужно
  где-то хранить, CI обычно предоставляет очень скромные средства, которых не
  хватает. В публичные места класть нельзя, тогда в хозяйстве появляется
  хранилище артефактов.

Что делать если проект распилен? Сгрузить все в один монорепозиторий. git даже
позволит сохранить историю. Делается в течение дня включая правку CI/CD.


Микросервисная архитектура
--------------------------

Классический булшит бинго. Если у вас стартап, вы ПМ и слышите от руководителя
бека, что будет микросервисная архитектура, то вы обречены). Гарантирую
сорванные сроки и постоянные проблемы во время разработки.

Они позволяют провести очень жесткие границы/интерфейсы между компонентами,
которые трудно нарушить, сложно впилить "временное решение проблемы", так как
нет широкого контекста, это безусловно хорошо. Но только когда эти самые
границы формально есть. На начальном этапе это будет только мешать.
Еще не известна предметная область, нет модели данных, нет финального списка
пользовательских историй, не собраны грабли, по сути, вообще ничего не известно, даже
кода нет, но уже принимается решение что жесткие границы нужны.

* Основная проблема заключается в коде который будет меняться по одной причине,
  но уже в нескольких сервисах одновременно, а так как микросервисы будут жить
  в нескольких репозиториях, то автоматически наследуются все проблемы,
  описанные в предыдущем разделе.

* Отлов багов будет труднее. Теперь ошибки придется искать по нескольким процессам.
  А если у вас успеют сформироваться подкоманды, отвечающие за разные сервисы
  (в примитивном варианте это будет Коля, делавший внешний HTTP API для фронта
  и Вася, писавший внутренний сервис биллинга), то появится тикетный пинг-понг.
  Первый "все передает правильно", а у второго "там просто нечему ломаться".

Строго говоря, микросервисы это и не архитектура вообще. Архитектура это
решения которые нужно принять сейчас. Микросервисы же можно всегда отложить на
потом.

Ключевой пойнт: разделение монолита происходит как закономерное развитие
проекта, когда приходит понимание что выделять, а самое главное, почему надо
выделять, какую проблему мы решаем. На начальном этапе таких проблем нет
и решать просто нечего.

Что делать если микросервисы уже появились? Скорее всего переубедить
лида, а тем более CTO не получится, сегодня это карго-культ. Так принято делать
у "белых" людей. Про то что них микросервисы появляются сильно после запуска, никого не
волнует, а синдром Вьетнама только закрепит опрометчивое решение.

Конфигурация
------------

Хранилища секретов, consul, etc.

Приватные репы
--------------

REST
----

GRAPHQL
-------

Декларативность
---------------

Общая шина
----------

Что наоборот нужно
------------------
